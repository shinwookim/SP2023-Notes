# Introduction
## Syllabus / Administrivia
+ Instructor: Luis Oliveria [loliveira@pitt.edu](mailto:loliveira@pitt.edu)
+ https://cs0449.gitlab.io/fa2022
+ Office: `5412 SENSQ`
+ Textbook
	+ The ANSI C Programming Language (2nd Edition) - _Brian Kernighan and Dennis Ritchie, 1988_ 
	+ Computer Systems: A Programmer’s Perspective (3rd Edition) - _Randal E. Bryant and David R. O’Hallaron, 2016_
+ Course Layout
	1. **Lectures** presents high-level concepts.
	2. **Recitation** applies concepts and introduces tools & skills for lab-work; clarifies lectures and review topics.
	3. **Programming Assignments (Labs)** provide deeper dive into some new skills or systems concepts; Programming, Measurement, Design; Roughly 1-2 weeks per assignments.
		1. **Collaboration** - Labs are individual assignment. Discussing is fine, but no sharing solutions.
		2. **Submission** - Electronic submission on GradeScope.
		3. **Linux** - Assignments must be performed in Linux, as grading is done in Linux
		4. **`Thoth` Machine** - `Thoth` is a machine in the CS department which runs Linux; It can be accessed via `ssh thoth@cs.pitt.edu` using University Computing Account.
		5. **Checkoff Meetings** - Short meeting with course graders to validate your submission; Must be completed within 10 days of the lab deadline; Without checkoff meetings, labs are graded as zero.
			+ If you fail Checkoff, you can do a second check off meeting with Instructor (no less than 24 hours after inital checkoff)
			+ If you are sick, email both instructor and grader prior to deadline.
		6. **Late Work** - 5 Late days are given to cover normal setbacks and schedule mishaps; See website for maximum number of late days per assignment.
			+ When you run out of late days: `-15% per each day`. Assignment cannot be submitted after the 3rd penalty day.
	5. **Homework** applies the knowledge gained in lecture to problems
		1. **Collaboration** - Homework can be done with another person; Discussion is useful to solve these problems.
	6. **2 Exams** tests comprehsion of concepts
+ Grading

 | Criteria | Percentage | Notes |
 |---------|--------------|--------|
|Labs|50%|Weighter according to effort|
|Quizzes| 5%|Taken during recitation|
|Exam 1| 15%|                       |
|Exam 2| 20%|Cumulative|
|Homework|10%|Online Problem Set|

+ Disability Resources / Services: Contact DRS `412-648-7890`; TTY: `412-383-7355`
+ Cheating: The default penalty is to be removed from the course with a failing grade. See online syllabus for full policy.
+ Conduct: Jokes/comments about sex, gender, race, ethnicity, religion, etc are not tolerated. Includes any online spaces involved.
## Course Oveview
### Topics
+ The C Systems Programming Language & x86 Assembly
	+ Abstractions and coping without them
	+ x86 assembly (ISA) / calling conventions (ABI)
	+ Interactive debugging
	+ Data representation
	+ We gain an appreciation of abstraction (and respecting limitations)
+ Memory Models
	+ Addresses and Pointers
	+ Memory management
+ Memory Caches
+ Operating Systems
	+ Processes / Signals
	+ Interprocess Communication
	+ The Basics of Virtual Memory
+ System Design
	+ Learning the “why” for many systems abstractions
	+ Manipulating systems and existing programs
	+ Thinking about how systems might change in the future
	+ We demystify software so as to no longer be a hostage to its design
### What is Systems?
+ Systems is broad
	+ A subfield of CS dealing with the interactions between software/hardware.
	+ A layer that provides abstractions and must constantly reevaluate them.
		+ Operating Systems
		+ File Systems
		+ Program Analysis / Debugging Tools
		+ Intra/Inter System Protocols
	+ A house built from trade-offs in approach…
		+ Do you build better hardware? Add more memory?
		+ Or, do you design better software?
	+ And trade-offs in design…
	+ Do you choose the specialized path?
	+ Or, do you create a general system?

### The C Programming Langauge
**C** was invented in 1972 alongside `UNIX` to an effort to aid application development of that system. Eventually `UNIX` itself was rewritten in C cementing C as a systems language. As such, C provides a **high-level abstraction of assembly / machine-code** and a low-**level abstraction of memory**, from the perspective of the C programmer.

Recall that in a modern computer (Von Neumann), all instructions are read from memory. Since C allows us to fully manipulate memory, it in turn, allows us to fully manipulate CPU and hardware. Furthermore, in understanding systems, C demystifies and reveals the underlying memory model and execution environment. Consequently, most operating systems are written in C; even when the entire OS is not written in C, it's often C-like (e.g., Linux device drivers.)

### Why learn systems?
Understanding systems means learning to mitigate errors and improve performance. Performance is especially important in systems because our abstractions might hurt the performance of every user application. (Abstraction is still important and is what helps alleviate design fatigue)
tigue. 

Learning about systems can also make us better programmers (even if we are programming in higher-level languages). For instance, if python itself crashes, you can still debug it since the python's interpreter is written in C.

As a tangent, we can also use systems skills to create art (using C). E.g., Real-time art, video games, *Demoscene*. Or we might use our skills to _break things_. For instance, we may remove copy-protection of old programs; reverse-engineer programs; break down a program's behavior, and then patch it to do/not-do things. Professional librarians/archivist do e this.
