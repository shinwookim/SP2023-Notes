# Introduction
## Syllabus / Administrivia
+ Instructor: Luis Oliveria [loliveira@pitt.edu](mailto:loliveira@pitt.edu)
+ https://cs0449.gitlab.io/fa2022
+ Office: `5412 SENSQ`
+ Textbook
	+ The ANSI C Programming Language (2nd Edition) - _Brian Kernighan and Dennis Ritchie, 1988_ 
	+ Computer Systems: A Programmer’s Perspective (3rd Edition) - _Randal E. Bryant and David R. O’Hallaron, 2016_
+ Course Layout
	1. **Lectures** presents high-level concepts.
	2. **Recitation** applies concepts and introduces tools & skills for lab-work; clarifies lectures and review topics.
	3. **Programming Assignments (Labs)** provide deeper dive into some new skills or systems concepts; Programming, Measurement, Design; Roughly 1-2 weeks per assignments.
		1. **Collaboration** - Labs are individual assignment. Discussing is fine, but no sharing solutions.
		2. **Submission** - Electronic submission on GradeScope.
		3. **Linux** - Assignments must be performed in Linux, as grading is done in Linux
		4. **`Thoth` Machine** - `Thoth` is a machine in the CS department which runs Linux; It can be accessed via `ssh thoth@cs.pitt.edu` using University Computing Account.
		5. **Checkoff Meetings** - Short meeting with course graders to validate your submission; Must be completed within 10 days of the lab deadline; Without checkoff meetings, labs are graded as zero.
			+ If you fail Checkoff, you can do a second check off meeting with Instructor (no less than 24 hours after inital checkoff)
			+ If you are sick, email both instructor and grader prior to deadline.
		6. **Late Work** - 5 Late days are given to cover normal setbacks and schedule mishaps; See website for maximum number of late days per assignment.
			+ When you run out of late days: `-15% per each day`. Assignment cannot be submitted after the 3rd penalty day.
	5. **Homework** applies the knowledge gained in lecture to problems
		1. **Collaboration** - Homework can be done with another person; Discussion is useful to solve these problems.
	6. **2 Exams** tests comprehsion of concepts
+ Grading
| Criteria | Percentage | Notes |
|---------|--------------|--------|
|Labs|50%|Weighter according to effort|
|Quizzes| 5%|Taken during recitation|
|Exam 1| 15%|                       |
|Exam 2| 20%|Cumulative|
|Homework|10%|Online Problem Set|

## Course Oveview
### Topics
+ The C Systems Programming Language & x86 Assembly
	+ Abstractions and coping without them
	+ x86 assembly (ISA) / calling conventions (ABI)
	+ Interactive debugging
	+ Data representation
	+ We gain an appreciation of abstraction (and respecting limitations)
+ Memory Models
	+ Addresses and Pointers
	+ Memory management
+ Memory Caches
+ Operating Systems
	+ Processes / Signals
	+ Interprocess Communication
	+ The Basics of Virtual Memory
+ System Design
	+ Learning the “why” for many systems abstractions
	+ Manipulating systems and existing programs
	+ Thinking about how systems might change in the future
	+ We demystify software so as to no longer be a hostage to its design

### What is Systems?
> Systems is a subfield of CS dealing with the interactions between software/hardware.  

*Systems* is a broad topic, but simply put, it focuses on the layer which provides abstractions for software/hardware interaction. It includes Operating Systems, File Systems, Program Analysis/Debugging Tools, Intra/Inter System Protocols.

Systems has many approaches and is very opinionated depending who you ask. For example, should we build better hardware, or design better software? Should we build a very specialized system, or a general adaptable system?

### The C Programming Langauge
**C** was invented in 1972 alongside `UNIX` to an effort to aid application development of that system. Eventually `UNIX` itself was rewritten in C cementing C as a systems language. As such, C provides a **high-level abstraction of assembly / machine-code** and a low-**level abstraction of memory**, from the perspective of the C programmer.

Recall that in a modern computer (Von Neumann), all instructions are read from memory. Since C allows us to fully manipulate memory, it in turn, allows us to fully manipulate CPU and hardware. Furthermore, in understanding systems, C demystifies and reveals the underlying memory model and execution environment. Consequently, most operating systems are written in C; even when the entire OS is not written in C, it's often C-like (e.g., Linux device drivers.)

### Why learn systems?
Understanding systems means learning to mitigate errors and improve performance. Performance is especially important in systems because our abstractions might hurt the performance of every user application. (Abstraction is still important and is what helps alleviate design fatigue)
tigue. 

Learning about systems can also make us better programmers (even if we are programming in higher-level languages). For instance, if python itself crashes, you can still debug it since the python's interpreter is written in C.

As a tangent, we can also use systems skills to create art (using C). E.g., Real-time art, video games, *Demoscene*. Or we might use our skills to _break things_. For instance, we may remove copy-protection of old programs; reverse-engineer programs; break down a program's behavior, and then patch it to do/not-do things. Professional librarians/archivist do exactly this.
