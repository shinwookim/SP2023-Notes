# Introduction
## Syllabus / Administrivia
+ Instructor: Luis Oliveria [loliveira@pitt.edu](mailto:loliveira@pitt.edu)
+ https://cs0449.gitlab.io/fa2022
+ Office: `5412 SENSQ`
+ Textbook
	+ The ANSI C Programming Language (2nd Edition) - _Brian Kernighan and Dennis Ritchie, 1988_ 
	+ Computer Systems: A Programmer’s Perspective (3rd Edition) - _Randal E. Bryant and David R. O’Hallaron, 2016_
+ Course Layout
	1. **Lectures** presents high-level concepts.
	2. **Recitation** applies concepts and introduces tools & skills for lab-work; clarifies lectures and review topics.
	3. **Programming Assignments (Labs)** provide deeper dive into some new skills or systems concepts; Programming, Measurement, Design; Roughly 1-2 weeks per assignments.
		1. **Collaboration** - Labs are individual assignment. Discussing is fine, but no sharing solutions.
		2. **Submission** - Electronic submission on GradeScope.
		3. **Linux** - Assignments must be performed in Linux, as grading is done in Linux
		4. **`Thoth` Machine** - `Thoth` is a machine in the CS department which runs Linux; It can be accessed via `ssh thoth@cs.pitt.edu` using University Computing Account.
		5. **Checkoff Meetings** - Short meeting with course graders to validate your submission; Must be completed within 10 days of the lab deadline; Without checkoff meetings, labs are graded as zero.
			+ If you fail Checkoff, you can do a second check off meeting with Instructor (no less than 24 hours after inital checkoff)
			+ If you are sick, email both instructor and grader prior to deadline.
		6. **Late Work** - 5 Late days are given to cover normal setbacks and schedule mishaps; See website for maximum number of late days per assignment.
			+ When you run out of late days: `-15% per each day`. Assignment cannot be submitted after the 3rd penalty day.
	5. **Homework** applies the knowledge gained in lecture to problems
		1. **Collaboration** - Homework can be done with another person; Discussion is useful to solve these problems.
	6. **2 Exams** tests comprehsion of concepts
+ Grading

 | Criteria | Percentage | Notes |
 |---------|--------------|--------|
|Labs|50%|Weighter according to effort|
|Quizzes| 5%|Taken during recitation|
|Exam 1| 15%|                       |
|Exam 2| 20%|Cumulative|
|Homework|10%|Online Problem Set|

+ Disability Resources / Services: Contact DRS `412-648-7890`; TTY: `412-383-7355`
+ Cheating: The default penalty is to be removed from the course with a failing grade. See online syllabus for full policy.
+ Conduct: Jokes/comments about sex, gender, race, ethnicity, religion, etc are not tolerated. Includes any online spaces involved.
## Course Oveview
### Topics
+ The C Systems Programming Language & x86 Assembly
	+ Abstractions and coping without them
	+ x86 assembly (ISA) / calling conventions (ABI)
	+ Interactive debugging
	+ Data representation
	+ We gain an appreciation of abstraction (and respecting limitations)
+ Memory Models
	+ Addresses and Pointers
	+ Memory management
+ Memory Caches
+ Operating Systems
	+ Processes / Signals
	+ Interprocess Communication
	+ The Basics of Virtual Memory
+ System Design
	+ Learning the “why” for many systems abstractions
	+ Manipulating systems and existing programs
	+ Thinking about how systems might change in the future
	+ We demystify software so as to no longer be a hostage to its design
### What is Systems?
+ Systems is broad
	+ A subfield of CS dealing with the interactions between software/hardware.
	+ A layer that provides abstractions and must constantly reevaluate them.
		+ Operating Systems
		+ File Systems
		+ Program Analysis / Debugging Tools
		+ Intra/Inter System Protocols
	+ A house built from trade-offs in approach…
		+ Do you build better hardware? Add more memory?
		+ Or, do you design better software?
	+ And trade-offs in design…
	+ Do you choose the specialized path?
	+ Or, do you create a general system?

### The C Programming Langauge
**C** was invented in 1972 alongside `UNIX` to an effort to aid application development of that system. Eventually `UNIX` itself was rewritten in C cementing C as a systems language. As such, C provides a **high-level abstraction of assembly / machine-code** and a low-**level abstraction of memory**, from the perspective of the C programmer.

This is important for programming systems code, because it allows full manipulation of memory (which in turn, allows for the full manipulation of CPU/hardware). 

For our purposes, C is great because it reveals the underlying memory model and execution environment. Even if the entire operating system is not written in C, it's often C-like (e.g., Linux Device Drivers). Thus understanding C is crucial to understanding systems.

Understanding systems means knowing how to mitigate/improve performance. Important that your abstractions don’t hurt performance because EVERY user application suffers. Yet, performance is not the only consideration; understanding abstractions should help alleviate design fatigue. 

It also helps us debug higher-level programs. E.g.,  `python` crashes, you can debug it because `python`'s interpreter is written in `C`.

You _can_ also create Art with `C`. (Real-time art, Video games; See _Demoscene_)

You can use these skills to _break things_. We can remove copy-protection of old programs; reverse-engineer programs. We can use a _debugger_ to break down a program's behavior, and then patch it to do/not-do things. Professional librarians/archivist  do this.
